<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Spelling Trainer</title>
    <style>
        /*
         * Combined styling from both the original spelling trainer and the
         * suggestions prototype.  The visual appearance retains the clear
         * layout and colours of the original while incorporating subtle
         * improvements such as rounded inputs and pill‑shaped suggestion
         * buttons.  Additional classes support highlighting potential
         * misspellings and rendering suggestion chips below each entry.
         */
        body {
            font-family: Arial, sans-serif;
            background: #f8f9fa;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        header {
            background: #4CAF50;
            color: white;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.5rem;
        }
        header nav a {
            color: white;
            margin-left: 20px;
            text-decoration: none;
            font-size: 1rem;
        }
        header nav a:hover {
            text-decoration: underline;
        }
        .container {
            flex: 1;
            padding: 1rem;
            max-width: 800px;
            margin: 0 auto;
        }
        .card {
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            padding: 1.5rem;
            margin-bottom: 1rem;
        }
        h2 {
            margin-top: 0;
        }
        /* Setup stage word entry rows */
        .word-entry {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .word-entry input[type="text"] {
            flex: 1;
            padding: 8px;
            font-size: 1rem;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        /* Highlight suspicious inputs */
        .word-entry input[type="text"].bad {
            border-color: #e5484d;
            background: #fff5f5;
        }
        .word-entry button.random-btn {
            margin-left: 8px;
            padding: 8px;
            font-size: 1.2rem;
            line-height: 1;
            background: #e6f4ea;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .word-entry button.random-btn:hover {
            background: #d5edd6;
        }
        /* Suggestion chips container */
        .sugs {
            margin-top: -0.25rem;
            margin-bottom: 0.5rem;
        }
        .pill {
            display: inline-block;
            margin: 2px 4px;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid #cbd5e1;
            background: #fff;
            cursor: pointer;
            font-size: 14px;
        }
        .pill:hover {
            background: #f1f5f9;
        }
        .hint {
            color: #6b7280;
            font-size: 13px;
        }
        /* Practice typing styles */
        #typing-practice {
            margin-top: 1rem;
        }
        #practice-inputs .practice-row {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        #practice-inputs .practice-row input {
            flex: 1;
            padding: 6px;
            font-size: 1rem;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        #practice-inputs .practice-row span.status {
            margin-left: 8px;
            font-size: 1.2rem;
        }
        /* Progress label */
        .progress {
            margin-bottom: 1rem;
            font-weight: bold;
        }
        /* Printable tracing sheet */
        .print-area {
            display: none;
            margin-top: 1rem;
            background: #fff;
            padding: 1rem;
            border: 1px solid #ccc;
        }
        button {
            background: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            margin: 0.5rem 0;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Home page layout */
        #home-card .home-content {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
        }
        #home-card .home-left {
            flex: 1;
            min-width: 250px;
        }
        #home-card .home-right {
            flex: 1;
            min-width: 200px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 1rem;
        }
        #home-card .home-title {
            margin: 0;
            font-size: 2rem;
        }
        #home-card .home-tagline {
            margin-top: 0.5rem;
            font-size: 1rem;
            color: #6b7280;
        }
        #home-card button {
            width: 200px;
        }

        /* Fade-in animation for view transitions */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .fadein {
            animation: fadeIn 0.4s ease forwards;
        }

        /* Secondary button style for utility actions */
        button.secondary {
            background: #e9ecef;
            color: #222;
        }
    </style>
</head>
<body>
    <header>
        <span class="logo-title">Spelling Practice for Dyslexia</span>
        <nav id="nav-bar">
            <a href="#" id="nav-home">Home</a>
            <a href="#" id="nav-new">New Practice</a>
            <a href="#" id="nav-saved">Saved Words</a>
            <a href="#" id="nav-learned">Learned Words</a>
        </nav>
    </header>
    <div class="container">
        <!-- Home Page -->
        <div id="home-card" class="card">
            <div class="home-content">
                <div class="home-left">
                    <h1 class="home-title">Spelling Practice for Dyslexia</h1>
                    <p class="home-tagline">Building spelling skills, one word at a time</p>
                </div>
                <div class="home-right">
                    <button id="home-new-btn">New Practice</button>
                    <button id="home-saved-btn">Saved Words</button>
                    <button id="home-learned-btn">Learned Words</button>
                </div>
            </div>
        </div>

        <!-- Learned Words Page -->
        <div id="learned-page" class="card" style="display:none;">
            <h2>Learned Words</h2>
            <ul id="learned-list-page" style="list-style:none;padding-left:0;"></ul>
            <button id="reset-learned-page-btn" class="secondary">Reset all</button>
        </div>

        <!-- Setup Stage -->
        <div id="setup-card" class="card" style="display:none;">
            <h2>Select Your Words</h2>
            <p>Enter up to five words you want to practise. You can also pick a random word for any box by clicking the dice. Each box accepts only one word.</p>
            <div id="word-fields">
                <!-- Each word entry has an input, a random button and a suggestion area -->
                <div class="word-entry">
                    <input type="text" id="w0" class="word-field" placeholder="Word 1" spellcheck="true">
                    <button class="random-btn" data-index="0" title="Pick a random word">🎲</button>
                </div>
                <div class="sugs" id="s0"></div>
                <div class="word-entry">
                    <input type="text" id="w1" class="word-field" placeholder="Word 2" spellcheck="true">
                    <button class="random-btn" data-index="1" title="Pick a random word">🎲</button>
                </div>
                <div class="sugs" id="s1"></div>
                <div class="word-entry">
                    <input type="text" id="w2" class="word-field" placeholder="Word 3" spellcheck="true">
                    <button class="random-btn" data-index="2" title="Pick a random word">🎲</button>
                </div>
                <div class="sugs" id="s2"></div>
                <div class="word-entry">
                    <input type="text" id="w3" class="word-field" placeholder="Word 4" spellcheck="true">
                    <button class="random-btn" data-index="3" title="Pick a random word">🎲</button>
                </div>
                <div class="sugs" id="s3"></div>
                <div class="word-entry">
                    <input type="text" id="w4" class="word-field" placeholder="Word 5" spellcheck="true">
                    <button class="random-btn" data-index="4" title="Pick a random word">🎲</button>
                </div>
                <div class="sugs" id="s4"></div>
            </div>
            <!-- Streak threshold selection: allow user to choose how many correct recalls mark a word as learned -->
            <div class="threshold-setting" style="margin:0.5rem 0;">
                <label for="streak-threshold">Correct recalls required to learn a word:</label>
                <select id="streak-threshold">
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                </select>
            </div>
            <button id="start-btn">Start Practice</button>
            <p class="hint">Tip: we’ll flag suspicious entries and suggest likely corrections.</p>

            <!-- Saved words section: appears when there is a saved set in localStorage -->
            <div id="saved-section" style="margin-top:1rem; display:none;">
                <h3>Saved Words</h3>
                <p id="saved-list"></p>
                <button id="resume-saved-btn">Practice saved words</button>
                <button id="clear-saved-btn" class="secondary">Clear saved set</button>
            </div>
            <!-- Learned words section: appears when words have been mastered -->
            <div id="learned-section" style="margin-top:1rem; display:none;">
                <h3>Learned Words</h3>
                <ul id="learned-list" style="list-style:none;padding-left:0;"></ul>
                <button id="reset-all-btn" class="secondary">Reset all learned</button>
            </div>
        </div>
        <!-- Practice Stage -->
        <div id="practice-card" class="card" style="display:none;">
            <div class="progress" id="progress-label"></div>
            <!-- Stage 1: presentation -->
            <div id="presentation-stage">
                <h2 id="current-word-display"></h2>
                <p class="syllables" id="syllable-display"></p>
                <p class="meaning" id="meaning-display"></p>
                <div id="typing-practice">
                    <p>Practise typing the word:</p>
                    <div id="practice-inputs"></div>
                    <button id="add-practice-btn" type="button">Add More</button>
                </div>
                <button id="listen-btn">🔊 Listen to Word</button>
                <button id="next-stage-btn">Next</button>
            </div>
            <!-- Stage 2: recall -->
            <div id="recall-stage" style="display:none;">
                <p>Listen to the word and type it from memory:</p>
                <button id="listen-again-btn">🔊 Listen Again</button>
                <input type="text" id="recall-input" placeholder="Type spelling here">
                <button id="check-btn">Check</button>
                <div class="message" id="recall-message"></div>
                <!-- Correction practice when wrong -->
                <div id="correction-area" style="display:none;">
                    <p>Type the correct spelling:</p>
                    <input type="text" id="correction-input" placeholder="Correct spelling">
                    <button id="correction-check-btn">Check Spelling</button>
                    <div class="message" id="correction-msg"></div>
                    <button id="retry-btn" style="display:none;">Try Again from Memory</button>
                </div>
            </div>
            <button id="next-word-btn" style="display:none;">Next Word</button>
            <button id="print-btn">Print Words for Tracing</button>
            <div id="print-area" class="print-area"></div>
        </div>
    </div>
    <script>
        // --- Common dictionary used both for random selection and suggestions ---
        const COMMON_WORDS = [
            'the', 'be', 'to', 'of', 'and', 'a', 'in', 'that', 'have', 'I', 'it', 'for', 'not', 'on',
            'with', 'he', 'as', 'you', 'do', 'at', 'this', 'but', 'his', 'by', 'from', 'they', 'we',
            'say', 'her', 'she', 'or', 'an', 'will', 'my', 'one', 'all', 'would', 'there', 'their',
            'what', 'so', 'up', 'out', 'if', 'about', 'who', 'get', 'which', 'go', 'me', 'when',
            'make', 'can', 'like', 'time', 'no', 'just', 'him', 'know', 'take', 'people', 'into',
            'year', 'your', 'good', 'some', 'could', 'them', 'see', 'other', 'than', 'then', 'now',
            'look', 'only', 'come', 'its', 'over', 'think', 'also', 'back', 'after', 'use', 'two',
            'how', 'our', 'work', 'first', 'well', 'way', 'even', 'new', 'want', 'because', 'any',
            'these', 'give', 'day', 'most', 'us', 'friend', 'beautiful', 'knowledge', 'phonetic',
            'through', 'though', 'thought', 'enough', 'again', 'against', 'begin', 'began', 'begun',
            'before', 'below', 'between', 'beyond', 'busy', 'cafe', 'coffee', 'colour', 'color',
            'centre', 'center', 'favourite', 'favorite', 'travelling', 'traveling', 'traveller',
            'traveler', 'theatre', 'theater', 'night', 'light', 'might', 'right', 'write', 'wrong',
            'read', 'reading', 'written', 'writing', 'learn', 'learning', 'practice', 'practise',
            'receive', 'believe', 'achieve', 'piece', 'peace', 'their', 'there', 'they', 'them',
            'those', 'these', 'that', 'this', 'whose', "who's", 'were', 'where', 'wear', "we're",
            'we', "you're", 'your', 'youre', 'you', 'does', "doesn't", "don't", 'did', "didn't",
            'was', "wasn't", 'is', "isn't", 'are', "aren't", 'am', "i'm", "I'm", 'morning',
            'afternoon', 'evening', 'tomorrow', 'today', 'yesterday', 'Saturday', 'Sunday', 'Monday',
            'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'January', 'February', 'March', 'April',
            'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December', 'easy',
            'difficult', 'simple', 'complex', 'correct', 'incorrect', 'spell', 'spelling', 'memory',
            'audio', 'listen', 'type', 'typing', 'chunks', 'chunk', 'syllable', 'syllables',
            'meaning', 'mnemonic', 'pattern', 'patterns', 'success', 'struggle', 'journey',
            'practice', 'encourage', 'reading', 'writing', 'learning', 'phonetic'
        ];

        // Use the dictionary as the pool for random words; filter for reasonable length
        function pickRandomWord(){
            const pool = COMMON_WORDS.filter(w => w.length >= 3 && w.length <= 10);
            return pool[Math.floor(Math.random()*pool.length)];
        }

        // Syllable heuristic used in the original trainer
        function splitIntoSyllables(word) {
            const vowels = ['a','e','i','o','u','y'];
            let parts=[]; let current='';
            for(let i=0;i<word.length;i++){
                const c=word[i];
                if(i!==0 && vowels.includes(c.toLowerCase())){
                    if(current) parts.push(current);
                    current=c;
                } else {
                    current+=c;
                }
            }
            if(current) parts.push(current);
            return parts.join('-');
        }

        // Simple speech synthesis wrapper
        function speak(text){
            if(typeof window.speechSynthesis!== 'undefined'){
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'en-US';
                window.speechSynthesis.speak(utterance);
            }
        }

        // ---- Suggestion and validation utilities (from suggestions prototype) ----
        function looksSuspicious(w){
            if(!w) return false;
            if(w.length < 2) return true;
            const vowels = /[aeiou]/i;
            if(!vowels.test(w)) return true;
            return false;
        }
        // Compute Levenshtein distance between two strings
        function lev(a,b){
            a = a.toLowerCase();
            b = b.toLowerCase();
            const m=a.length, n=b.length;
            const dp=new Array(n+1);
            for(let j=0;j<=n;j++) dp[j]=j;
            for(let i=1;i<=m;i++){
                let prev = dp[0]; dp[0] = i;
                for(let j=1;j<=n;j++){
                    const tmp = dp[j];
                    const cost = a[i-1]===b[j-1] ? 0 : 1;
                    dp[j] = Math.min(
                        dp[j] + 1,      // deletion
                        dp[j-1] + 1,     // insertion
                        prev + cost      // substitution
                    );
                    prev = tmp;
                }
            }
            return dp[n];
        }
        function getSuggestions(word, limit=5){
            if(!word) return [];
            const maxDist = word.length <= 3 ? 1 : 2;
            const cand = [];
            for(const w of COMMON_WORDS){
                const d = lev(word, w);
                if(d <= maxDist) cand.push([w,d]);
            }
            cand.sort((a,b) => a[1] - b[1] || a[0].localeCompare(b[0]));
            const seen = new Set();
            const out = [];
            for(const [w,d] of cand){
                if(!seen.has(w)){
                    out.push(w);
                    seen.add(w);
                }
                if(out.length >= limit) break;
            }
            return out;
        }
        function renderSuggestions(i, list){
            const sug = document.getElementById('s'+i);
            if(!sug) return;
            sug.innerHTML = '';
            if(!list || !list.length) return;
            const label = document.createElement('div');
            label.className = 'hint';
            label.textContent = 'Did you mean:';
            sug.appendChild(label);
            for(const w of list){
                const pill = document.createElement('span');
                pill.className = 'pill';
                pill.textContent = w;
                pill.onclick = () => {
                    const input = document.getElementById('w'+i);
                    if(input) input.value = w;
                    clearBad(i);
                    renderSuggestions(i, []);
                };
                sug.appendChild(pill);
            }
        }
        function markBad(i){
            const inp = document.getElementById('w'+i);
            if(inp) inp.classList.add('bad');
        }
        function clearBad(i){
            const inp = document.getElementById('w'+i);
            if(inp) inp.classList.remove('bad');
        }

        // ---- Practice logic variables and helpers ----
        let wordList = [];
        let currentIndex = 0;
        // Track per-word practice history including attempts, correct counts, streaks and learned status.
        // The keys are the original word spellings (case sensitive), and values are objects
        // with shape { attempts: number, correct: number, streak: number, learned: boolean }.
        let practiceHistory = {};
        // Default mastery streak threshold. The user can choose 3, 4 or 5 correct recalls in a row.
        let masteryStreak = 3;

        // ---- Persistence helpers (localStorage) ----
        // Store and restore your word list and progress across sessions.  The state
        // consists of the current list of words, the index of the word you are
        // practising, and a timestamp.  If the user leaves the page and comes
        // back later, the app can resume from where they left off.
        const STORAGE_KEY = 'spellingTrainer:v2';
        // Duration to keep a saved set (7 days in milliseconds)
        const SAVE_DURATION = 7 * 24 * 60 * 60 * 1000;
        function saveState(extra = {}) {
            try {
                const state = {
                    wordList,
                    currentIndex,
                    lastUpdated: Date.now(),
                    // Always persist practice history and mastery threshold so that learned status
                    // and user preferences survive reloads and across sessions.
                    history: practiceHistory,
                    threshold: masteryStreak,
                    ...extra
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
            } catch (e) {
                console.warn('Could not save state', e);
            }
        }
        function loadState() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if(!raw) return null;
                const state = JSON.parse(raw);
                // If the saved data has expired, clear it and return null
                if(state && state.lastUpdated && (Date.now() - state.lastUpdated > SAVE_DURATION)){
                    clearState();
                    return null;
                }
                return state;
            } catch (e) {
                console.warn('Could not load state', e);
                return null;
            }
        }
        function clearState() {
            localStorage.removeItem(STORAGE_KEY);
        }

        // DOM references for practice stage (declared later in DOMContentLoaded)
        let practiceCard, startBtn, progressLabel, currentWordDisplay,
            syllableDisplay, meaningDisplay, listenBtn, nextStageBtn,
            presentationStage, recallStage, listenAgainBtn, recallInput,
            checkBtn, recallMessage, nextWordBtn, printBtn, printArea,
            wordFields, randomBtns, practiceInputsContainer, addPracticeBtn,
            correctionArea, correctionInput, correctionCheckBtn,
            correctionMsg, retryBtn;

        // Create a practice row for typing practise
        function createPracticeRow(word){
            const row = document.createElement('div');
            row.className = 'practice-row';
            const input = document.createElement('input');
            input.type = 'text';
            input.placeholder = 'Type the word';
            const status = document.createElement('span');
            status.className = 'status';
            row.appendChild(input);
            row.appendChild(status);
            practiceInputsContainer.appendChild(row);
            input.addEventListener('input', () => { checkPracticeInput(input, status, word); });
        }
        function checkPracticeInput(input, statusSpan, correctWord){
            const val = input.value.trim().toLowerCase();
            if(val === ''){ statusSpan.textContent = ''; return; }
            if(val === correctWord.toLowerCase()){
                statusSpan.textContent = '✓';
                statusSpan.style.color = 'green';
            } else {
                statusSpan.textContent = '✗';
                statusSpan.style.color = 'red';
            }
        }
        function updateProgress(){
            // Use active words (not learned) to compute progress
            const totalActive = countActiveWords();
            let currentActiveIndex = 0;
            for(let i = 0; i < wordList.length; i++){
                const w = wordList[i].word;
                if(!practiceHistory[w] || !practiceHistory[w].learned){
                    currentActiveIndex++;
                }
                if(i === currentIndex) break;
            }
            if(totalActive === 0){
                progressLabel.textContent = '';
            } else {
                progressLabel.textContent = `Word ${currentActiveIndex} of ${totalActive}`;
            }
        }
        function setupPracticeInputs(word){
            practiceInputsContainer.innerHTML = '';
            for(let i=0; i<3; i++) createPracticeRow(word);
            addPracticeBtn.style.display = '';
        }
        function loadCurrentWord(){
            // Skip learned words until we find an active word or reach the end
            while (currentIndex < wordList.length) {
                const w = wordList[currentIndex].word;
                if (practiceHistory[w] && practiceHistory[w].learned) {
                    currentIndex++;
                    continue;
                }
                break;
            }
            // If all words are learned, show a message and allow restart
            if (countActiveWords() === 0) {
                currentWordDisplay.textContent = 'All words mastered!';
                syllableDisplay.textContent = '';
                meaningDisplay.textContent = '';
                practiceInputsContainer.innerHTML = '';
                addPracticeBtn.style.display = 'none';
                presentationStage.style.display = '';
                recallStage.style.display = 'none';
                nextWordBtn.style.display = 'none';
                printBtn.disabled = false;
                progressLabel.textContent = '';
                // Reset index so user can practise again if desired
                currentIndex = 0;
                saveState();
                updateLearnedSection();
                updateSavedSection();
                return;
            }
            // If we've reached the end of the list but there are active words earlier,
            // wrap around to the start and continue.
            if (currentIndex >= wordList.length) {
                currentIndex = 0;
                saveState();
                loadCurrentWord();
                return;
            }
            updateProgress();
            const { word, meaning, syllables } = wordList[currentIndex];
            currentWordDisplay.textContent = word;
            syllableDisplay.textContent = `Chunks: ${syllables}`;
            meaningDisplay.textContent = meaning ? `Meaning: ${meaning}` : '';
            recallInput.value = '';
            recallMessage.textContent = '';
            correctionInput.value = '';
            correctionMsg.textContent = '';
            correctionArea.style.display = 'none';
            retryBtn.style.display = 'none';
            presentationStage.style.display = '';
            recallStage.style.display = 'none';
            nextWordBtn.style.display = 'none';
            printBtn.disabled = true;
            setupPracticeInputs(word);
            // Save progress after setting up the current word
            saveState();
        }
        function showRecallStage(){
            presentationStage.style.display = 'none';
            recallStage.style.display = '';
        }
        function checkAnswer(){
            const userRaw = recallInput.value.trim();
            const userAnswer = userRaw.toLowerCase();
            const item = wordList[currentIndex];
            const correctRaw = item.word;
            const correctWord = correctRaw.toLowerCase();
            // Initialize practice history entry if not present
            if (!practiceHistory[correctRaw]) {
                practiceHistory[correctRaw] = { attempts: 0, correct: 0, streak: 0, learned: false };
            }
            const record = practiceHistory[correctRaw];
            record.attempts++;
            if (userAnswer === correctWord) {
                record.correct++;
                record.streak++;
                recallMessage.textContent = '✅ Correct!';
                recallMessage.style.color = 'green';
                correctionArea.style.display = 'none';
                // If the word reaches mastery threshold and is not already marked as learned
                if (record.streak >= masteryStreak && !record.learned) {
                    record.learned = true;
                    alert(`${correctRaw} mastered!`);
                    saveState();
                    updateLearnedSection();
                    // Move to the next word automatically
                    nextWord();
                    return;
                }
                // Otherwise show the next word button
                nextWordBtn.style.display = '';
            } else {
                // Incorrect: reset streak
                record.streak = 0;
                recallMessage.innerHTML = `❌ Oops! The correct spelling is: <strong>${correctRaw}</strong>`;
                recallMessage.style.color = 'red';
                nextWordBtn.style.display = 'none';
                correctionArea.style.display = '';
                correctionMsg.textContent = '';
                retryBtn.style.display = 'none';
                correctionInput.value = '';
            }
            // Persist updated practice history and threshold
            saveState();
        }
        function checkCorrection(){
            const correctWord = wordList[currentIndex].word;
            const val = correctionInput.value.trim();
            if(val.toLowerCase() === correctWord.toLowerCase()){
                correctionMsg.textContent = 'Great job! Now try from memory again.';
                correctionMsg.style.color = 'green';
                retryBtn.style.display = '';
            } else {
                correctionMsg.textContent = 'Oops, that is not quite right. Try again.';
                correctionMsg.style.color = 'red';
                retryBtn.style.display = 'none';
            }
        }
        function retryMemory(){
            correctionArea.style.display = 'none';
            correctionMsg.textContent = '';
            recallInput.value = '';
            recallMessage.textContent = "Let's try again!";
            recallMessage.style.color = '';
            retryBtn.style.display = 'none';
            speak(wordList[currentIndex].word);
        }
        function nextWord(){
            currentIndex++;
            // Persist the updated index so progress survives page reloads
            saveState();
            loadCurrentWord();
        }
        function updatePrintArea(){
            let html = '<h2>Trace Your Words</h2>';
            html += '<p>Use the lines below to trace and practise each word.</p>';
            html += '<ul style="list-style:none;padding:0;">';
            wordList.forEach(item => {
                html += `<li style="margin-bottom:20px;"><strong>${item.word}</strong><br>`;
                for(let i=0; i<3; i++) html += `${'_'.repeat(item.word.length)}<br>`;
                html += '</li>';
            });
            html += '</ul>';

            printArea.innerHTML = html;
        }

        // Update the saved words section on the setup page.  If a set has been
        // saved and has not expired, this will display the words and reveal
        // the resume/clear buttons.  Otherwise the section is hidden.
        function updateSavedSection(){
            const savedSection = document.getElementById('saved-section');
            const savedListEl = document.getElementById('saved-list');
            if(!savedSection || !savedListEl) return;
            const saved = loadState();
            if(saved && saved.wordList && saved.wordList.length){
                savedSection.style.display = '';
                // Format list of words; each entry may be an object with a 'word' property
                const names = saved.wordList.map(item => (typeof item === 'string' ? item : item.word)).join(', ');
                savedListEl.textContent = names;
            } else {
                savedSection.style.display = 'none';
            }
        }

        // Count how many words are still active (i.e., not yet learned). Uses practiceHistory and wordList.
        function countActiveWords() {
            let active = 0;
            for (const item of wordList) {
                const w = item.word;
                const rec = practiceHistory[w];
                if (!rec || !rec.learned) {
                    active++;
                }
            }
            return active;
        }

        // Update the learned words section. Displays all words marked as learned with an option to unarchive.
        function updateLearnedSection() {
            const learnedSection = document.getElementById('learned-section');
            const listEl = document.getElementById('learned-list');
            const learnedPage = document.getElementById('learned-page');
            const listPage = document.getElementById('learned-list-page');
            if (!learnedSection || !listEl) return;
            const learnedWords = [];
            for (const w in practiceHistory) {
                const rec = practiceHistory[w];
                if (rec && rec.learned) {
                    learnedWords.push(w);
                }
            }
            if (learnedWords.length > 0) {
                // Update the section inside the setup page
                learnedSection.style.display = '';
                listEl.innerHTML = '';
                learnedWords.forEach(word => {
                    const li = document.createElement('li');
                    const span = document.createElement('span');
                    span.textContent = word;
                    li.appendChild(span);
                    const btn = document.createElement('button');
                    btn.textContent = 'Unarchive';
                    btn.className = 'secondary';
                    btn.style.marginLeft = '8px';
                    btn.onclick = () => {
                        if (practiceHistory[word]) {
                            practiceHistory[word].learned = false;
                            practiceHistory[word].streak = 0;
                        }
                        saveState();
                        updateLearnedSection();
                        updateProgress();
                    };
                    li.appendChild(btn);
                    listEl.appendChild(li);
                });
                // Update the learned words page
                if (listPage) {
                    listPage.innerHTML = '';
                    learnedWords.forEach(word => {
                        const li = document.createElement('li');
                        const span = document.createElement('span');
                        span.textContent = word;
                        li.appendChild(span);
                        const btn = document.createElement('button');
                        btn.textContent = 'Learn again';
                        btn.className = 'secondary';
                        btn.style.marginLeft = '8px';
                        btn.onclick = () => {
                            if (practiceHistory[word]) {
                                practiceHistory[word].learned = false;
                                practiceHistory[word].streak = 0;
                            }
                            saveState();
                            updateLearnedSection();
                            updateProgress();
                        };
                        li.appendChild(btn);
                        listPage.appendChild(li);
                    });
                }
            } else {
                // No learned words: hide section in setup page and show a message in the page
                learnedSection.style.display = 'none';
                listEl.innerHTML = '';
                if (listPage) {
                    listPage.innerHTML = '<li><em>No learned words yet.</em></li>';
                }
            }
        }

        // Switch between pages (home, setup, practice) with a simple fade-in effect.
        // pageId should be one of 'home-card', 'setup-card', or 'practice-card'.
        // An optional anchorId can be provided to scroll to a section after the page is shown.
        function showPage(pageId, anchorId) {
            const pages = ['home-card', 'setup-card', 'practice-card', 'learned-page'];
            pages.forEach(pid => {
                const el = document.getElementById(pid);
                if(el) {
                    if(pid === pageId) {
                        el.style.display = '';
                        // Trigger fade-in animation
                        el.classList.add('fadein');
                        setTimeout(() => { el.classList.remove('fadein'); }, 500);
                    } else {
                        el.style.display = 'none';
                    }
                }
            });
            // When showing the setup page or learned page, ensure sections are refreshed
            if(pageId === 'setup-card') {
                if(typeof updateSavedSection === 'function') updateSavedSection();
                if(typeof updateLearnedSection === 'function') updateLearnedSection();
            }
            if(pageId === 'learned-page') {
                if(typeof updateLearnedSection === 'function') updateLearnedSection();
            }
            // Scroll to a specific anchor inside the page if provided
            if(anchorId) {
                const anchor = document.getElementById(anchorId);
                if(anchor) {
                    // Use setTimeout to allow the page to display before scrolling
                    setTimeout(() => {
                        anchor.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }, 10);
                }
            }
        }

        // ---- Setup event handlers once DOM is ready ----
        document.addEventListener('DOMContentLoaded', () => {
            // Grab DOM elements
            practiceCard = document.getElementById('practice-card');
            startBtn = document.getElementById('start-btn');
            progressLabel = document.getElementById('progress-label');
            currentWordDisplay = document.getElementById('current-word-display');
            syllableDisplay = document.getElementById('syllable-display');
            meaningDisplay = document.getElementById('meaning-display');
            listenBtn = document.getElementById('listen-btn');
            nextStageBtn = document.getElementById('next-stage-btn');
            presentationStage = document.getElementById('presentation-stage');
            recallStage = document.getElementById('recall-stage');
            listenAgainBtn = document.getElementById('listen-again-btn');
            recallInput = document.getElementById('recall-input');
            checkBtn = document.getElementById('check-btn');
            recallMessage = document.getElementById('recall-message');
            nextWordBtn = document.getElementById('next-word-btn');
            printBtn = document.getElementById('print-btn');
            printArea = document.getElementById('print-area');
            wordFields = document.querySelectorAll('.word-field');
            randomBtns = document.querySelectorAll('.random-btn');
            practiceInputsContainer = document.getElementById('practice-inputs');
            addPracticeBtn = document.getElementById('add-practice-btn');
            correctionArea = document.getElementById('correction-area');
            correctionInput = document.getElementById('correction-input');
            correctionCheckBtn = document.getElementById('correction-check-btn');
            correctionMsg = document.getElementById('correction-msg');
            retryBtn = document.getElementById('retry-btn');

            // Restore saved history and mastery threshold on page load.  This allows the app to
            // remember which words were learned and the selected streak threshold.
            const savedState = loadState();
            const thresholdSelect = document.getElementById('streak-threshold');
            if (savedState) {
                // If a history object was saved, restore it
                if (savedState.history) {
                    practiceHistory = savedState.history;
                }
                // If a threshold value was saved, restore it
                if (savedState.threshold) {
                    masteryStreak = savedState.threshold;
                }
                // Update the threshold dropdown to reflect the saved value
                if (thresholdSelect && masteryStreak) {
                    thresholdSelect.value = masteryStreak.toString();
                }
            }
            // Update learned words display based on restored state
            if (typeof updateLearnedSection === 'function') updateLearnedSection();

            // Random button handlers
            randomBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const idx = parseInt(btn.getAttribute('data-index'));
                    const input = document.getElementById('w' + idx);
                    if(input){
                        input.value = pickRandomWord();
                        clearBad(idx);
                        renderSuggestions(idx, []);
                    }
                });
            });

            // Start practice handler with suggestions and validation
            startBtn.addEventListener('click', () => {
                const words = [];
                const flagged = [];
                // Iterate over each input field by index
                for(let i = 0; i < 5; i++){
                    const input = document.getElementById('w' + i);
                    if(!input) continue;
                    const raw = (input.value || '').trim();
                    // clear previous hints
                    renderSuggestions(i, []);
                    clearBad(i);
                    if(!raw) continue;
                    const token = raw.split(/\s+/)[0];
                    // enforce single word
                    input.value = token;
                    const suspicious = looksSuspicious(token);
                    const sugs = suspicious ? getSuggestions(token, 5) : [];
                    if(suspicious){
                        markBad(i);
                        renderSuggestions(i, sugs);
                        flagged.push({i, w: token, sugs});
                    } else {
                        // not suspicious; still provide suggestions if word not exactly in dictionary
                        if(!COMMON_WORDS.includes(token.toLowerCase())){
                            const extra = getSuggestions(token, 5);
                            renderSuggestions(i, extra);
                        }
                    }
                    words.push({word: token, meaning: '', syllables: splitIntoSyllables(token)});
                }
                // Filter out empty entries
                const activeWords = words.filter(item => item.word && item.word.length > 0);
                if(activeWords.length === 0){
                    alert('Please enter at least one word.');
                    return;
                }
                // If any suspicious entries, prompt user
                if(flagged.length){
                    const msg = 'The following words may be misspelled or missing vowels:\n\n' +
                        flagged.map(f => '• ' + f.w + (f.sugs.length ? '  (suggestions: ' + f.sugs.join(', ') + ')' : '')).join('\n') +
                        '\n\nFix them or press OK to practise anyway.';
                    if(!confirm(msg)) return;
                }
                // Save list and move to practice
                // Reset practice history for a new set and read the mastery threshold from the select
                practiceHistory = {};
                const selectElement = document.getElementById('streak-threshold');
                if (selectElement) {
                    masteryStreak = parseInt(selectElement.value) || 3;
                    // Disable the selector during an active practice session to prevent mid-session changes
                    selectElement.disabled = true;
                } else {
                    masteryStreak = 3;
                }
                wordList = activeWords;
                currentIndex = 0;
                // Persist initial state before starting practice (includes history and threshold)
                saveState();
                // Ensure learned section is refreshed when starting a new practice session
                updateLearnedSection();
                // Switch to the practice view with fade transition
                showPage('practice-card');
                updatePrintArea();
                loadCurrentWord();
            });
            // Add more practice row handler
            addPracticeBtn.addEventListener('click', () => {
                if(currentIndex < wordList.length) createPracticeRow(wordList[currentIndex].word);
            });
            // Audio handlers
            listenBtn.addEventListener('click', () => {
                if(currentIndex < wordList.length) speak(wordList[currentIndex].word);
            });
            listenAgainBtn.addEventListener('click', () => {
                if(currentIndex < wordList.length) speak(wordList[currentIndex].word);
            });
            // Navigate to recall stage
            nextStageBtn.addEventListener('click', showRecallStage);
            // Check recall answer
            checkBtn.addEventListener('click', checkAnswer);
            // Check correction
            correctionCheckBtn.addEventListener('click', checkCorrection);
            // Retry memory from correction flow
            retryBtn.addEventListener('click', retryMemory);
            // Move to next word
            nextWordBtn.addEventListener('click', nextWord);
            // Toggle print area
            printBtn.addEventListener('click', () => {
                if(printArea.style.display === 'none' || printArea.style.display === ''){
                    printArea.style.display = 'block';
                } else {
                    printArea.style.display = 'none';
                }
            });

            // Resume saved words or clear saved set actions
            const resumeSavedBtn = document.getElementById('resume-saved-btn');
            const clearSavedBtn = document.getElementById('clear-saved-btn');
            if (resumeSavedBtn) {
                resumeSavedBtn.addEventListener('click', () => {
                    const savedSet = loadState();
                    if (savedSet && savedSet.wordList && savedSet.wordList.length) {
                        wordList = savedSet.wordList;
                        currentIndex = 0;
                        // Restore history and threshold for the saved session
                        if (savedSet.history) {
                            practiceHistory = savedSet.history;
                        }
                        if (savedSet.threshold) {
                            masteryStreak = savedSet.threshold;
                        }
                        const streakSel = document.getElementById('streak-threshold');
                        if (streakSel) {
                            streakSel.value = masteryStreak.toString();
                            streakSel.disabled = true;
                        }
                        // Switch to practice view
                        showPage('practice-card');
                        updatePrintArea();
                        updateLearnedSection();
                        loadCurrentWord();
                    }
                });
            }
            if (clearSavedBtn) {
                clearSavedBtn.addEventListener('click', () => {
                    clearState();
                    // Reset local practice history and re-enable threshold selector
                    practiceHistory = {};
                    const streakSel = document.getElementById('streak-threshold');
                    if (streakSel) {
                        streakSel.disabled = false;
                    }
                    updateSavedSection();
                    updateLearnedSection();
                });
            }

            // Reset all learned words to active when clicking the reset button
            const resetAllBtn = document.getElementById('reset-all-btn');
            if (resetAllBtn) {
                resetAllBtn.addEventListener('click', () => {
                    // Iterate through practiceHistory and mark all words as not learned with zero streak
                    for (const w in practiceHistory) {
                        const rec = practiceHistory[w];
                        if (rec) {
                            rec.learned = false;
                            rec.streak = 0;
                        }
                    }
                    saveState();
                    updateLearnedSection();
                    updateProgress();
                });
            }

            // Reset all learned words from the learned page
            const resetLearnedPageBtn = document.getElementById('reset-learned-page-btn');
            if (resetLearnedPageBtn) {
                resetLearnedPageBtn.addEventListener('click', () => {
                    for (const w in practiceHistory) {
                        const rec = practiceHistory[w];
                        if (rec) {
                            rec.learned = false;
                            rec.streak = 0;
                        }
                    }
                    saveState();
                    updateLearnedSection();
                    updateProgress();
                });
            }

            // Navigation bar handlers
            const navHome = document.getElementById('nav-home');
            if (navHome) navHome.addEventListener('click', (e) => { e.preventDefault(); showPage('home-card'); });
            const navNew = document.getElementById('nav-new');
            if (navNew) navNew.addEventListener('click', (e) => { e.preventDefault(); showPage('setup-card'); });
            const navSaved = document.getElementById('nav-saved');
            if (navSaved) navSaved.addEventListener('click', (e) => { e.preventDefault(); showPage('setup-card', 'saved-section'); });
            const navLearned = document.getElementById('nav-learned');
            if (navLearned) navLearned.addEventListener('click', (e) => { e.preventDefault(); showPage('learned-page'); });

            // Home page button handlers
            const homeNewBtn = document.getElementById('home-new-btn');
            if (homeNewBtn) homeNewBtn.addEventListener('click', () => { showPage('setup-card'); });
            const homeSavedBtn = document.getElementById('home-saved-btn');
            if (homeSavedBtn) homeSavedBtn.addEventListener('click', () => { showPage('setup-card', 'saved-section'); });
            const homeLearnedBtn = document.getElementById('home-learned-btn');
            if (homeLearnedBtn) homeLearnedBtn.addEventListener('click', () => { showPage('learned-page'); });

            // On initial load, display the home page by default
            showPage('home-card');

            // Update saved and learned sections on initial load
            if (typeof updateSavedSection === 'function') updateSavedSection();
            if (typeof updateLearnedSection === 'function') updateLearnedSection();

            // Check for previously saved state and offer to resume the session.  If the
            // user made partial progress (currentIndex between 1 and wordList.length-1),
            // prompt them to continue from where they left off.  If they decline, reset
            // the progress but keep the saved words so they remain available via
            // the saved words section.  When the saved set is fresh or completed (i.e.
            // currentIndex is 0 or undefined), skip the prompt and simply show the
            // saved words section.
            const saved = loadState();
            if (saved && saved.wordList && saved.wordList.length) {
                const idx = saved.currentIndex || 0;
                const total = saved.wordList.length;
                const inProgress = idx > 0 && idx < total;
                if (inProgress) {
                    if (confirm(`Resume your last session with ${saved.wordList.length} word(s)?`)) {
                        // Restore history and threshold
                        if (saved.history) {
                            practiceHistory = saved.history;
                        }
                        if (saved.threshold) {
                            masteryStreak = saved.threshold;
                        }
                        // Resume from where the user left off
                        wordList = saved.wordList;
                        currentIndex = Math.min(idx, wordList.length);
                        const streakSel = document.getElementById('streak-threshold');
                        if (streakSel) {
                            streakSel.value = masteryStreak.toString();
                            streakSel.disabled = true;
                        }
                        // Switch to practice view
                        showPage('practice-card');
                        updatePrintArea();
                        updateLearnedSection();
                        loadCurrentWord();
                    } else {
                        // User declined to resume; reset progress but keep the saved words
                        wordList = saved.wordList;
                        currentIndex = 0;
                        // Persist the reset state (which includes the history and threshold)
                        saveState();
                        if (typeof updateSavedSection === 'function') updateSavedSection();
                        if (typeof updateLearnedSection === 'function') updateLearnedSection();
                    }
                }
                // If not in progress, the saved words and learned words sections will already be
                // rendered by updateSavedSection() and updateLearnedSection().
            }
        });
    </script>
</body>
</html>