<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WordWise</title>
    <style>
        /*
         * Combined styling from both the original spelling trainer and the
         * suggestions prototype.  The visual appearance retains the clear
         * layout and colours of the original while incorporating subtle
         * improvements such as rounded inputs and pill‚Äëshaped suggestion
         * buttons.  Additional classes support highlighting potential
         * misspellings and rendering suggestion chips below each entry.
         */
        /*
         * Global layout and typography
         * Use a soft serif face to match the organic theme and apply the blurred
         * plant background throughout the app.  Cards sit on top of the
         * background using translucent white panels.  The header floats
         * transparently over the background with a subtle backdrop blur.
         */
        body {
            font-family: Georgia, "Times New Roman", serif;
            /* Apply the soft green background image across the entire page */
            /* Soft gradient reminiscent of the green plant background with seedlings anchored to the bottom.  Using multiple
               backgrounds allows us to show the gradient across the page and the seedlings image at the bottom without the
               original text. */
            background: linear-gradient(to bottom right, #eaf7d8 0%, #d7eac0 50%, #b5d488 100%), url('1.png');
            background-repeat: no-repeat, no-repeat;
            background-position: center center, bottom center;
            /* scale the seedlings graphic to a reasonable height; adjust as needed */
            background-size: cover, auto 220px;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        header {
            /* Semi‚Äëtransparent header that floats above the background */
            background: rgba(255,255,255,0.7);
            backdrop-filter: blur(5px);
            color: #333;
            padding: 0.75rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.25rem;
        }
        header .logo-container {
            display: flex;
            align-items: center;
        }
        header .logo-container img {
            height: 36px;
            width: auto;
            margin-right: 0.5rem;
        }
        /* The emoji icon used for the logo.  Sized to align with the text. */
        header .logo-icon {
            font-size: 2rem;
            line-height: 1;
            margin-right: 0.5rem;
        }
        header .logo-title {
            font-size: 1.5rem;
            font-weight: normal;
            color: #333;
        }
        header nav a {
            color: #333;
            margin-left: 20px;
            text-decoration: none;
            font-size: 1rem;
        }
        header nav a:hover {
            text-decoration: underline;
        }
        .container {
            flex: 1;
            padding: 1rem;
            max-width: 800px;
            margin: 0 auto;
        }
        /* Panels (cards) float above the background with translucent white and a soft shadow */
        .card {
            background: rgba(255,255,255,0.9);
            border-radius: 8px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
            padding: 1.5rem;
            margin-bottom: 1rem;
        }
        h2 {
            margin-top: 0;
        }
        /* Setup stage word entry rows */
        .word-entry {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .word-entry input[type="text"] {
            flex: 1;
            padding: 8px;
            font-size: 1rem;
            border: 1px solid rgba(0,0,0,0.3);
            border-radius: 4px;
            background: rgba(255,255,255,0.8);
            color: #333;
        }
        /* Highlight suspicious inputs */
        .word-entry input[type="text"].bad {
            border-color: #e5484d;
            background: #fff5f5;
        }
        .word-entry button.random-btn {
            margin-left: 8px;
            padding: 8px;
            font-size: 1.2rem;
            line-height: 1;
            background: #e6f4ea;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .word-entry button.random-btn:hover {
            background: #d5edd6;
        }
        /* Suggestion chips container */
        .sugs {
            margin-top: -0.25rem;
            margin-bottom: 0.5rem;
        }
        .pill {
            display: inline-block;
            margin: 2px 4px;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid #cbd5e1;
            background: #fff;
            cursor: pointer;
            font-size: 14px;
        }
        .pill:hover {
            background: #f1f5f9;
        }
        .hint {
            color: #6b7280;
            font-size: 13px;
        }
        /* Practice typing styles */
        #typing-practice {
            margin-top: 1rem;
        }
        #practice-inputs .practice-row {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        #practice-inputs .practice-row input {
            flex: 1;
            padding: 6px;
            font-size: 1rem;
            border: 1px solid rgba(0,0,0,0.3);
            border-radius: 4px;
            background: rgba(255,255,255,0.8);
            color: #333;
        }
        #practice-inputs .practice-row span.status {
            margin-left: 8px;
            font-size: 1.2rem;
        }
        /* Progress label */
        .progress {
            margin-bottom: 1rem;
            font-weight: bold;
        }
        /* Printable tracing sheet */
        .print-area {
            display: none;
            margin-top: 1rem;
            background: #fff;
            padding: 1rem;
            border: 1px solid #ccc;
        }
        button {
            background: rgba(255,255,255,0.8);
            color: #333;
            padding: 10px 20px;
            border: 1px solid #333;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            margin: 0.5rem 0;
            transition: background 0.2s, color 0.2s;
        }
        button:hover {
            background: rgba(255,255,255,0.95);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Home page layout */
        #home-card .home-content {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
        }
        #home-card .home-left {
            flex: 1;
            min-width: 250px;
        }
        #home-card .home-right {
            flex: 1;
            min-width: 200px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 1rem;
        }
        #home-card .home-title {
            margin: 0;
            font-size: 2rem;
        }
        #home-card .home-tagline {
            margin-top: 0.5rem;
            font-size: 1rem;
            color: #6b7280;
        }
        #home-card button {
            width: 200px;
        }

        /* Fade-in animation for view transitions */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .fadein {
            animation: fadeIn 0.4s ease forwards;
        }

        /* Secondary button style for utility actions */
        button.secondary {
            background: rgba(255,255,255,0.6);
            color: #333;
            border-color: #666;
        }

        /* Print stylesheet: show only the print-sheet div when printing */
        @media print {
            body * { visibility: hidden !important; }
            #print-sheet { visibility: visible !important; display:block !important; position: static; }
        }
    </style>
</head>
<body>
    <header>
        <div class="logo-container">
            <!-- Use an emoji book icon instead of an external image for reliability -->
            <span class="logo-icon">üìñ</span>
            <span class="logo-title">WordWise</span>
        </div>
        <nav id="nav-bar">
            <a href="#" id="nav-home">Home</a>
            <a href="#" id="nav-new">New Practice</a>
            <a href="#" id="nav-saved">Saved Words</a>
            <a href="#" id="nav-learned">Learned Words</a>
        </nav>
    </header>
    <div class="container">
        <!-- Home Page -->
        <div id="home-card" class="card">
            <div class="home-content">
                <div class="home-left">
                    <h1 class="home-title">WordWise</h1>
                    <p class="home-tagline">Building spelling skills, one word at a time</p>
                </div>
                <div class="home-right">
                    <button id="home-new-btn">New Practice</button>
                    <button id="home-saved-btn">Saved Words</button>
                    <button id="home-learned-btn">Learned Words</button>
                </div>
            </div>
        </div>

        <!-- Congrats Page (shown after finishing daily practice) -->
        <div id="congrats-card" class="card" style="display:none; text-align:center;">
            <h2>Great job today! üéâ</h2>
            <p>You‚Äôve completed today‚Äôs practice.</p>
            <p>Next session unlocks in <span id="unlock-countdown">--:--:--</span></p>
            <div style="margin-top:1rem;">
                <button id="go-saved">Saved Words</button>
                <button id="go-learned">Learned Words</button>
            </div>
            <details style="margin-top:1rem;">
                <summary>Override (teacher)</summary>
                <button id="override-unlock" class="secondary">Unlock today</button>
            </details>
        </div>

        <!-- Learned Words Page -->
        <div id="learned-page" class="card" style="display:none;">
            <h2>Learned Words</h2>
            <ul id="learned-list-page" style="list-style:none;padding-left:0;"></ul>
            <button id="reset-learned-page-btn" class="secondary">Reset all</button>
        </div>

        <!-- Setup Stage -->
        <div id="setup-card" class="card" style="display:none;">
            <h2>Select Your Words</h2>
            <p>Enter up to five words you want to practise. You can also pick a random word for any box by clicking the dice. Each box accepts only one word.</p>
            <div id="word-fields">
                <!-- Each word entry has an input, a random button and a suggestion area -->
                <div class="word-entry">
                    <input type="text" id="w0" class="word-field" placeholder="Word 1" spellcheck="true">
                    <button class="random-btn" data-index="0" title="Pick a random word">üé≤</button>
                </div>
                <div class="sugs" id="s0"></div>
                <div class="word-entry">
                    <input type="text" id="w1" class="word-field" placeholder="Word 2" spellcheck="true">
                    <button class="random-btn" data-index="1" title="Pick a random word">üé≤</button>
                </div>
                <div class="sugs" id="s1"></div>
                <div class="word-entry">
                    <input type="text" id="w2" class="word-field" placeholder="Word 3" spellcheck="true">
                    <button class="random-btn" data-index="2" title="Pick a random word">üé≤</button>
                </div>
                <div class="sugs" id="s2"></div>
                <div class="word-entry">
                    <input type="text" id="w3" class="word-field" placeholder="Word 4" spellcheck="true">
                    <button class="random-btn" data-index="3" title="Pick a random word">üé≤</button>
                </div>
                <div class="sugs" id="s3"></div>
                <div class="word-entry">
                    <input type="text" id="w4" class="word-field" placeholder="Word 5" spellcheck="true">
                    <button class="random-btn" data-index="4" title="Pick a random word">üé≤</button>
                </div>
                <div class="sugs" id="s4"></div>
            </div>
            <!-- Streak threshold selection: allow user to choose how many correct recalls mark a word as learned -->
            <div class="threshold-setting" style="margin:0.5rem 0;">
                <label for="streak-threshold">Correct recalls required to learn a word:</label>
                <select id="streak-threshold">
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                </select>
            </div>
            <button id="start-btn">Start Practice</button>
            <p class="hint">Tip: we‚Äôll flag suspicious entries and suggest likely corrections.</p>

            <!-- Saved words section: appears when there is a saved set in localStorage -->
            <div id="saved-section" style="margin-top:1rem; display:none;">
                <h3>Saved Words</h3>
                <p id="saved-list"></p>
                <button id="resume-saved-btn">Practice saved words</button>
                <button id="clear-saved-btn" class="secondary">Clear saved set</button>
            </div>
            <!-- Learned words section: appears when words have been mastered -->
            <div id="learned-section" style="margin-top:1rem; display:none;">
                <h3>Learned Words</h3>
                <ul id="learned-list" style="list-style:none;padding-left:0;"></ul>
                <button id="reset-all-btn" class="secondary">Reset all learned</button>
            </div>
        </div>
        <!-- Practice Stage -->
        <div id="practice-card" class="card" style="display:none;">
            <div class="progress" id="progress-label"></div>
            <!-- Stage 1: presentation -->
            <div id="presentation-stage">
                <h2 id="current-word-display"></h2>
                <p class="syllables" id="syllable-display"></p>
                <p class="meaning" id="meaning-display"></p>
                <div id="typing-practice">
                    <p>Practise typing the word:</p>
                    <div id="practice-inputs"></div>
                    <button id="add-practice-btn" type="button">Add More</button>
                </div>
                <button id="listen-btn">üîä Listen to Word</button>
                <button id="next-stage-btn">Next</button>
            </div>
            <!-- Stage 2: recall -->
            <div id="recall-stage" style="display:none;">
                <p>Listen to the word and type it from memory:</p>
                <button id="listen-again-btn">üîä Listen Again</button>
                <input type="text" id="recall-input" placeholder="Type spelling here" style="background: rgba(255,255,255,0.8); border: 1px solid rgba(0,0,0,0.3); color: #333; padding:6px; border-radius:4px;">
                <button id="check-btn">Check</button>
                <div class="message" id="recall-message"></div>
                <!-- Correction practice when wrong -->
                <div id="correction-area" style="display:none;">
                    <p>Type the correct spelling:</p>
                    <input type="text" id="correction-input" placeholder="Correct spelling" style="background: rgba(255,255,255,0.8); border: 1px solid rgba(0,0,0,0.3); color: #333; padding:6px; border-radius:4px;">
                    <button id="correction-check-btn">Check Spelling</button>
                    <div class="message" id="correction-msg"></div>
                    <button id="retry-btn" style="display:none;">Try Again from Memory</button>
                </div>
            </div>
            <button id="next-word-btn" style="display:none;">Next Word</button>
            <button id="print-btn">Print Words for Tracing</button>
            <div id="print-area" class="print-area"></div>
        </div>
    </div>

    <!-- Hidden tracing worksheet for printing.  When the print button is clicked, this
         div is populated with tracing lines and printed via window.print().  It is
         hidden on screen but visible when printing via CSS below. -->
    <div id="print-sheet" style="display:none; padding:1in;"></div>
    <script>
        // --- Common dictionary used both for random selection and suggestions ---
        const COMMON_WORDS = [
            'the', 'be', 'to', 'of', 'and', 'a', 'in', 'that', 'have', 'I', 'it', 'for', 'not', 'on',
            'with', 'he', 'as', 'you', 'do', 'at', 'this', 'but', 'his', 'by', 'from', 'they', 'we',
            'say', 'her', 'she', 'or', 'an', 'will', 'my', 'one', 'all', 'would', 'there', 'their',
            'what', 'so', 'up', 'out', 'if', 'about', 'who', 'get', 'which', 'go', 'me', 'when',
            'make', 'can', 'like', 'time', 'no', 'just', 'him', 'know', 'take', 'people', 'into',
            'year', 'your', 'good', 'some', 'could', 'them', 'see', 'other', 'than', 'then', 'now',
            'look', 'only', 'come', 'its', 'over', 'think', 'also', 'back', 'after', 'use', 'two',
            'how', 'our', 'work', 'first', 'well', 'way', 'even', 'new', 'want', 'because', 'any',
            'these', 'give', 'day', 'most', 'us', 'friend', 'beautiful', 'knowledge', 'phonetic',
            'through', 'though', 'thought', 'enough', 'again', 'against', 'begin', 'began', 'begun',
            'before', 'below', 'between', 'beyond', 'busy', 'cafe', 'coffee', 'colour', 'color',
            'centre', 'center', 'favourite', 'favorite', 'travelling', 'traveling', 'traveller',
            'traveler', 'theatre', 'theater', 'night', 'light', 'might', 'right', 'write', 'wrong',
            'read', 'reading', 'written', 'writing', 'learn', 'learning', 'practice', 'practise',
            'receive', 'believe', 'achieve', 'piece', 'peace', 'their', 'there', 'they', 'them',
            'those', 'these', 'that', 'this', 'whose', "who's", 'were', 'where', 'wear', "we're",
            'we', "you're", 'your', 'youre', 'you', 'does', "doesn't", "don't", 'did', "didn't",
            'was', "wasn't", 'is', "isn't", 'are', "aren't", 'am', "i'm", "I'm", 'morning',
            'afternoon', 'evening', 'tomorrow', 'today', 'yesterday', 'Saturday', 'Sunday', 'Monday',
            'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'January', 'February', 'March', 'April',
            'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December', 'easy',
            'difficult', 'simple', 'complex', 'correct', 'incorrect', 'spell', 'spelling', 'memory',
            'audio', 'listen', 'type', 'typing', 'chunks', 'chunk', 'syllable', 'syllables',
            'meaning', 'mnemonic', 'pattern', 'patterns', 'success', 'struggle', 'journey',
            'practice', 'encourage', 'reading', 'writing', 'learning', 'phonetic'
        ];

        // Use the dictionary as the pool for random words; filter for reasonable length
        function pickRandomWord(){
            const pool = COMMON_WORDS.filter(w => w.length >= 3 && w.length <= 10);
            return pool[Math.floor(Math.random()*pool.length)];
        }

        // Syllable heuristic used in the original trainer
        function splitIntoSyllables(word) {
            const vowels = ['a','e','i','o','u','y'];
            let parts=[]; let current='';
            for(let i=0;i<word.length;i++){
                const c=word[i];
                if(i!==0 && vowels.includes(c.toLowerCase())){
                    if(current) parts.push(current);
                    current=c;
                } else {
                    current+=c;
                }
            }
            if(current) parts.push(current);
            return parts.join('-');
        }

        // Simple speech synthesis wrapper
        function speak(text){
            if(typeof window.speechSynthesis!== 'undefined'){
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'en-US';
                window.speechSynthesis.speak(utterance);
            }
        }

        // ---- Suggestion and validation utilities (from suggestions prototype) ----
        function looksSuspicious(w){
            if(!w) return false;
            if(w.length < 2) return true;
            const vowels = /[aeiou]/i;
            if(!vowels.test(w)) return true;
            return false;
        }
        // Compute Levenshtein distance between two strings
        function lev(a,b){
            a = a.toLowerCase();
            b = b.toLowerCase();
            const m=a.length, n=b.length;
            const dp=new Array(n+1);
            for(let j=0;j<=n;j++) dp[j]=j;
            for(let i=1;i<=m;i++){
                let prev = dp[0]; dp[0] = i;
                for(let j=1;j<=n;j++){
                    const tmp = dp[j];
                    const cost = a[i-1]===b[j-1] ? 0 : 1;
                    dp[j] = Math.min(
                        dp[j] + 1,      // deletion
                        dp[j-1] + 1,     // insertion
                        prev + cost      // substitution
                    );
                    prev = tmp;
                }
            }
            return dp[n];
        }
        function getSuggestions(word, limit=5){
            if(!word) return [];
            const maxDist = word.length <= 3 ? 1 : 2;
            const cand = [];
            for(const w of COMMON_WORDS){
                const d = lev(word, w);
                if(d <= maxDist) cand.push([w,d]);
            }
            cand.sort((a,b) => a[1] - b[1] || a[0].localeCompare(b[0]));
            const seen = new Set();
            const out = [];
            for(const [w,d] of cand){
                if(!seen.has(w)){
                    out.push(w);
                    seen.add(w);
                }
                if(out.length >= limit) break;
            }
            return out;
        }
        function renderSuggestions(i, list){
            const sug = document.getElementById('s'+i);
            if(!sug) return;
            sug.innerHTML = '';
            if(!list || !list.length) return;
            const label = document.createElement('div');
            label.className = 'hint';
            label.textContent = 'Did you mean:';
            sug.appendChild(label);
            for(const w of list){
                const pill = document.createElement('span');
                pill.className = 'pill';
                pill.textContent = w;
                pill.onclick = () => {
                    const input = document.getElementById('w'+i);
                    if(input) input.value = w;
                    clearBad(i);
                    renderSuggestions(i, []);
                };
                sug.appendChild(pill);
            }
        }
        function markBad(i){
            const inp = document.getElementById('w'+i);
            if(inp) inp.classList.add('bad');
        }
        function clearBad(i){
            const inp = document.getElementById('w'+i);
            if(inp) inp.classList.remove('bad');
        }

        // ---- Practice logic variables and helpers ----
        let wordList = [];
        let currentIndex = 0;
        // Track per-word practice history including attempts, correct counts, streaks and learned status.
        // The keys are the original word spellings (case sensitive), and values are objects
        // with shape { attempts: number, correct: number, streak: number, learned: boolean }.
        let practiceHistory = {};
        // Default mastery streak threshold. The user can choose 3, 4 or 5 correct recalls in a row.
        let masteryStreak = 3;

        // ---- Persistence helpers (localStorage) ----
        // Store and restore your word list and progress across sessions.  The state
        // consists of the current list of words, the index of the word you are
        // practising, and a timestamp.  If the user leaves the page and comes
        // back later, the app can resume from where they left off.
        const STORAGE_KEY = 'spellingTrainer:v2';
        // Duration to keep a saved set (7 days in milliseconds)
        const SAVE_DURATION = 7 * 24 * 60 * 60 * 1000;

        // Daily lock helpers.  When the user finishes practice, we store the last practice date
        // (YYYY-MM-DD) and a timestamp indicating midnight of the next day.  If the current
        // date matches the stored lastPracticeDate, the app is considered locked until
        // midnight.  The congrats page will display a countdown and provide override
        // controls for teachers/admins.
        function yyyymmdd(d = new Date()) {
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        function nextMidnightTs() {
            const now = new Date();
            const nm = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 0, 0, 0);
            return nm.getTime();
        }
        function isLockedToday(saved) {
            const today = yyyymmdd();
            return saved && saved.lastPracticeDate === today;
        }
        function saveState(extra = {}) {
            try {
                // Load any existing state so unmentioned properties (e.g. lastPracticeDate, lockedUntil)
                // are preserved on subsequent saves.
                const prev = loadState() || {};
                const state = {
                    ...prev,
                    wordList,
                    currentIndex,
                    lastUpdated: Date.now(),
                    // Always persist practice history and mastery threshold so that learned status
                    // and user preferences survive reloads and across sessions.
                    history: practiceHistory,
                    threshold: masteryStreak,
                    ...extra
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
            } catch (e) {
                console.warn('Could not save state', e);
            }
        }
        function loadState() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if(!raw) return null;
                const state = JSON.parse(raw);
                // If the saved data has expired, clear it and return null
                if(state && state.lastUpdated && (Date.now() - state.lastUpdated > SAVE_DURATION)){
                    clearState();
                    return null;
                }
                return state;
            } catch (e) {
                console.warn('Could not load state', e);
                return null;
            }
        }
        function clearState() {
            localStorage.removeItem(STORAGE_KEY);
        }

        // DOM references for practice stage (declared later in DOMContentLoaded)
        let practiceCard, startBtn, progressLabel, currentWordDisplay,
            syllableDisplay, meaningDisplay, listenBtn, nextStageBtn,
            presentationStage, recallStage, listenAgainBtn, recallInput,
            checkBtn, recallMessage, nextWordBtn, printBtn, printArea,
            wordFields, randomBtns, practiceInputsContainer, addPracticeBtn,
            correctionArea, correctionInput, correctionCheckBtn,
            correctionMsg, retryBtn;

        // Create a practice row for typing practise
        function createPracticeRow(word){
            const row = document.createElement('div');
            row.className = 'practice-row';
            const input = document.createElement('input');
            input.type = 'text';
            input.placeholder = 'Type the word';
            const status = document.createElement('span');
            status.className = 'status';
            row.appendChild(input);
            row.appendChild(status);
            practiceInputsContainer.appendChild(row);
            input.addEventListener('input', () => { checkPracticeInput(input, status, word); });
        }
        function checkPracticeInput(input, statusSpan, correctWord){
            const val = input.value.trim().toLowerCase();
            if(val === ''){ statusSpan.textContent = ''; return; }
            if(val === correctWord.toLowerCase()){
                statusSpan.textContent = '‚úì';
                statusSpan.style.color = 'green';
            } else {
                statusSpan.textContent = '‚úó';
                statusSpan.style.color = 'red';
            }
        }
        function updateProgress(){
            // Use active words (not learned) to compute progress
            const totalActive = countActiveWords();
            let currentActiveIndex = 0;
            for(let i = 0; i < wordList.length; i++){
                const w = wordList[i].word;
                if(!practiceHistory[w] || !practiceHistory[w].learned){
                    currentActiveIndex++;
                }
                if(i === currentIndex) break;
            }
            if(totalActive === 0){
                progressLabel.textContent = '';
            } else {
                progressLabel.textContent = `Word ${currentActiveIndex} of ${totalActive}`;
            }
        }
        function setupPracticeInputs(word){
            practiceInputsContainer.innerHTML = '';
            for(let i=0; i<3; i++) createPracticeRow(word);
            addPracticeBtn.style.display = '';
        }
        function loadCurrentWord(){
            // Skip learned words until we find an active word or reach the end
            while (currentIndex < wordList.length) {
                const w = wordList[currentIndex].word;
                if (practiceHistory[w] && practiceHistory[w].learned) {
                    currentIndex++;
                    continue;
                }
                break;
            }
            // If all words are learned, show a message and allow restart
            if (countActiveWords() === 0) {
                // All words mastered for today. Record the date and lock until next day.
                finishPracticeForDay();
                return;
            }
            // If we've reached the end of the list but there are active words earlier,
            // wrap around to the start and continue.
            if (currentIndex >= wordList.length) {
                currentIndex = 0;
                saveState();
                loadCurrentWord();
                return;
            }
            updateProgress();
            const { word, meaning, syllables } = wordList[currentIndex];
            currentWordDisplay.textContent = word;
            syllableDisplay.textContent = `Chunks: ${syllables}`;
            meaningDisplay.textContent = meaning ? `Meaning: ${meaning}` : '';
            recallInput.value = '';
            recallMessage.textContent = '';
            correctionInput.value = '';
            correctionMsg.textContent = '';
            correctionArea.style.display = 'none';
            retryBtn.style.display = 'none';
            presentationStage.style.display = '';
            recallStage.style.display = 'none';
            nextWordBtn.style.display = 'none';
            // Enable print button so tracing worksheet can be generated at any time
            if (printBtn) {
                printBtn.disabled = false;
                printBtn.removeAttribute('disabled');
            }
            setupPracticeInputs(word);
            // Save progress after setting up the current word
            saveState();
        }
        function showRecallStage(){
            presentationStage.style.display = 'none';
            recallStage.style.display = '';
        }
        function checkAnswer(){
            const userRaw = recallInput.value.trim();
            const userAnswer = userRaw.toLowerCase();
            const item = wordList[currentIndex];
            const correctRaw = item.word;
            const correctWord = correctRaw.toLowerCase();
            // Initialize practice history entry if not present
            if (!practiceHistory[correctRaw]) {
                practiceHistory[correctRaw] = { attempts: 0, correct: 0, streak: 0, learned: false };
            }
            const record = practiceHistory[correctRaw];
            record.attempts++;
            if (userAnswer === correctWord) {
                record.correct++;
                record.streak++;
                recallMessage.textContent = '‚úÖ Correct!';
                recallMessage.style.color = 'green';
                correctionArea.style.display = 'none';
                // If the word reaches mastery threshold and is not already marked as learned
                if (record.streak >= masteryStreak && !record.learned) {
                    record.learned = true;
                    alert(`${correctRaw} mastered!`);
                    saveState();
                    updateLearnedSection();
                    // Move to the next word automatically
                    nextWord();
                    return;
                }
                // Otherwise show the next word button
                nextWordBtn.style.display = '';
            } else {
                // Incorrect: reset streak
                record.streak = 0;
                recallMessage.innerHTML = `‚ùå Oops! The correct spelling is: <strong>${correctRaw}</strong>`;
                recallMessage.style.color = 'red';
                nextWordBtn.style.display = 'none';
                correctionArea.style.display = '';
                correctionMsg.textContent = '';
                retryBtn.style.display = 'none';
                correctionInput.value = '';
            }
            // Persist updated practice history and threshold
            saveState();
        }
        function checkCorrection(){
            const correctWord = wordList[currentIndex].word;
            const val = correctionInput.value.trim();
            if(val.toLowerCase() === correctWord.toLowerCase()){
                correctionMsg.textContent = 'Great job! Now try from memory again.';
                correctionMsg.style.color = 'green';
                retryBtn.style.display = '';
            } else {
                correctionMsg.textContent = 'Oops, that is not quite right. Try again.';
                correctionMsg.style.color = 'red';
                retryBtn.style.display = 'none';
            }
        }
        function retryMemory(){
            correctionArea.style.display = 'none';
            correctionMsg.textContent = '';
            recallInput.value = '';
            recallMessage.textContent = "Let's try again!";
            recallMessage.style.color = '';
            retryBtn.style.display = 'none';
            speak(wordList[currentIndex].word);
        }
        function nextWord(){
            currentIndex++;
            // Persist the updated index so progress survives page reloads
            saveState();
            loadCurrentWord();
        }

        // When a practice session is completed (all words mastered), lock further practice
        // until the next day.  This records the last practice date and the next
        // midnight timestamp, stores them in localStorage, and shows the congrats page.
        function finishPracticeForDay() {
            // Construct a minimal UI message
            // Hide the practice view to avoid confusion
            if (practiceCard) {
                practiceCard.style.display = 'none';
            }
            // Update state: record lastPracticeDate and lockedUntil (next midnight)
            const state = loadState() || {};
            state.lastPracticeDate = yyyymmdd();
            state.lockedUntil = nextMidnightTs();
            // Reset currentIndex to zero so next session starts from beginning
            currentIndex = 0;
            saveState(state);
            // Show the congrats page
            showPage('congrats-card');
            // Refresh saved/learned sections
            updateSavedSection();
            updateLearnedSection();
        }

        // Display a live countdown on the congrats page showing time until
        // midnight (unlock time).  If the countdown reaches zero, the daily
        // lock is cleared and the home page is shown.  Called when showing
        // the congrats page.
        function startDailyCountdown() {
            const el = document.getElementById('unlock-countdown');
            const saved = loadState();
            if (!el || !saved || !saved.lockedUntil) return;
            function tick() {
                const ms = Math.max(0, saved.lockedUntil - Date.now());
                const totalSec = Math.floor(ms / 1000);
                const hh = String(Math.floor(totalSec / 3600)).padStart(2, '0');
                const mm = String(Math.floor((totalSec % 3600) / 60)).padStart(2, '0');
                const ss = String(totalSec % 60).padStart(2, '0');
                el.textContent = `${hh}:${mm}:${ss}`;
                if (ms <= 0) {
                    // Unlock: clear lock and return to home page
                    const st = loadState() || {};
                    delete st.lastPracticeDate;
                    delete st.lockedUntil;
                    saveState(st);
                    showPage('home-card');
                    return;
                }
                setTimeout(tick, 1000);
            }
            tick();
        }
        function updatePrintArea(){
            let html = '<h2>Trace Your Words</h2>';
            html += '<p>Use the lines below to trace and practise each word.</p>';
            html += '<ul style="list-style:none;padding:0;">';
            wordList.forEach(item => {
                html += `<li style="margin-bottom:20px;"><strong>${item.word}</strong><br>`;
                for(let i=0; i<3; i++) html += `${'_'.repeat(item.word.length)}<br>`;
                html += '</li>';
            });
            html += '</ul>';

            printArea.innerHTML = html;
        }

        // Generate a printable worksheet for tracing the current word list.  Opens a new
        // window with a simple layout containing each word followed by three lines of
        // underscores.  Users can use the browser's Print dialog to save as PDF.
        function generateTracingWorksheet() {
            if (!wordList || wordList.length === 0) {
                alert('No words to print.');
                return;
            }
            const sheet = document.getElementById('print-sheet');
            if (!sheet) return;
            // Build HTML inside the print-sheet div
            let content = '<h1 style="margin-top:0;">Word Tracing Practice</h1>';
            wordList.forEach(item => {
                const word = item.word || item;
                // Heading for the word
                content += `<h2 style="margin-bottom:0.25in;">${word}</h2>`;
                // Create a table with three rows; each cell represents a letter space with a bottom border
                content += '<table style="border-collapse:collapse; margin-bottom:0.5in;">';
                for(let r=0; r<3; r++) {
                    content += '<tr>';
                    for(let i=0; i<word.length; i++) {
                        content += '<td style="border-bottom:2px solid #000; width:0.6in; height:0.4in;">&nbsp;</td>';
                    }
                    content += '</tr>';
                }
                content += '</table>';
            });
            sheet.innerHTML = content;
            // Temporarily reveal the sheet on screen (still hidden by CSS) then print
            sheet.style.display = 'block';
            window.print();
            // After printing, hide the sheet again to restore layout
            sheet.style.display = 'none';
        }

        // Update the saved words section on the setup page.  If a set has been
        // saved and has not expired, this will display the words and reveal
        // the resume/clear buttons.  Otherwise the section is hidden.
        function updateSavedSection(){
            const savedSection = document.getElementById('saved-section');
            const savedListEl = document.getElementById('saved-list');
            if(!savedSection || !savedListEl) return;
            const saved = loadState();
            if(saved && saved.wordList && saved.wordList.length){
                savedSection.style.display = '';
                // Format list of words; each entry may be an object with a 'word' property
                const names = saved.wordList.map(item => (typeof item === 'string' ? item : item.word)).join(', ');
                savedListEl.textContent = names;
            } else {
                savedSection.style.display = 'none';
            }
        }

        // Count how many words are still active (i.e., not yet learned). Uses practiceHistory and wordList.
        function countActiveWords() {
            let active = 0;
            for (const item of wordList) {
                const w = item.word;
                const rec = practiceHistory[w];
                if (!rec || !rec.learned) {
                    active++;
                }
            }
            return active;
        }

        // Update the learned words section. Displays all words marked as learned with an option to unarchive.
        function updateLearnedSection() {
            const learnedSection = document.getElementById('learned-section');
            const listEl = document.getElementById('learned-list');
            const learnedPage = document.getElementById('learned-page');
            const listPage = document.getElementById('learned-list-page');
            if (!learnedSection || !listEl) return;
            const learnedWords = [];
            for (const w in practiceHistory) {
                const rec = practiceHistory[w];
                if (rec && rec.learned) {
                    learnedWords.push(w);
                }
            }
            if (learnedWords.length > 0) {
                // Update the section inside the setup page
                learnedSection.style.display = '';
                listEl.innerHTML = '';
                learnedWords.forEach(word => {
                    const li = document.createElement('li');
                    const span = document.createElement('span');
                    span.textContent = word;
                    li.appendChild(span);
                    const btn = document.createElement('button');
                    btn.textContent = 'Unarchive';
                    btn.className = 'secondary';
                    btn.style.marginLeft = '8px';
                    btn.onclick = () => {
                        if (practiceHistory[word]) {
                            practiceHistory[word].learned = false;
                            practiceHistory[word].streak = 0;
                        }
                        saveState();
                        updateLearnedSection();
                        updateProgress();
                    };
                    li.appendChild(btn);
                    listEl.appendChild(li);
                });
                // Update the learned words page
                if (listPage) {
                    listPage.innerHTML = '';
                    learnedWords.forEach(word => {
                        const li = document.createElement('li');
                        const span = document.createElement('span');
                        span.textContent = word;
                        li.appendChild(span);
                        const btn = document.createElement('button');
                        btn.textContent = 'Learn again';
                        btn.className = 'secondary';
                        btn.style.marginLeft = '8px';
                        btn.onclick = () => {
                            if (practiceHistory[word]) {
                                practiceHistory[word].learned = false;
                                practiceHistory[word].streak = 0;
                            }
                            saveState();
                            updateLearnedSection();
                            updateProgress();
                        };
                        li.appendChild(btn);
                        listPage.appendChild(li);
                    });
                }
            } else {
                // No learned words: hide section in setup page and show a message in the page
                learnedSection.style.display = 'none';
                listEl.innerHTML = '';
                if (listPage) {
                    listPage.innerHTML = '<li><em>No learned words yet.</em></li>';
                }
            }
        }

        // Switch between pages (home, setup, practice) with a simple fade-in effect.
        // pageId should be one of 'home-card', 'setup-card', or 'practice-card'.
        // An optional anchorId can be provided to scroll to a section after the page is shown.
        function showPage(pageId, anchorId) {
            const pages = ['home-card', 'setup-card', 'practice-card', 'learned-page', 'congrats-card'];
            pages.forEach(pid => {
                const el = document.getElementById(pid);
                if(el) {
                    if(pid === pageId) {
                        el.style.display = '';
                        // Trigger fade-in animation
                        el.classList.add('fadein');
                        setTimeout(() => { el.classList.remove('fadein'); }, 500);
                    } else {
                        el.style.display = 'none';
                    }
                }
            });
            // When showing the setup page or learned page, ensure sections are refreshed
            if(pageId === 'setup-card') {
                if(typeof updateSavedSection === 'function') updateSavedSection();
                if(typeof updateLearnedSection === 'function') updateLearnedSection();
            }
            if(pageId === 'learned-page') {
                if(typeof updateLearnedSection === 'function') updateLearnedSection();
            }
            // When showing the congrats page, update the countdown timer
            if(pageId === 'congrats-card') {
                if (typeof startDailyCountdown === 'function') startDailyCountdown();
            }
            // Scroll to a specific anchor inside the page if provided
            if(anchorId) {
                const anchor = document.getElementById(anchorId);
                if(anchor) {
                    // Use setTimeout to allow the page to display before scrolling
                    setTimeout(() => {
                        anchor.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }, 10);
                }
            }
        }

        // ---- Setup event handlers once DOM is ready ----
        document.addEventListener('DOMContentLoaded', () => {
            // Grab DOM elements
            practiceCard = document.getElementById('practice-card');
            startBtn = document.getElementById('start-btn');
            progressLabel = document.getElementById('progress-label');
            currentWordDisplay = document.getElementById('current-word-display');
            syllableDisplay = document.getElementById('syllable-display');
            meaningDisplay = document.getElementById('meaning-display');
            listenBtn = document.getElementById('listen-btn');
            nextStageBtn = document.getElementById('next-stage-btn');
            presentationStage = document.getElementById('presentation-stage');
            recallStage = document.getElementById('recall-stage');
            listenAgainBtn = document.getElementById('listen-again-btn');
            recallInput = document.getElementById('recall-input');
            checkBtn = document.getElementById('check-btn');
            recallMessage = document.getElementById('recall-message');
            nextWordBtn = document.getElementById('next-word-btn');
            printBtn = document.getElementById('print-btn');
            printArea = document.getElementById('print-area');
            wordFields = document.querySelectorAll('.word-field');
            randomBtns = document.querySelectorAll('.random-btn');
            practiceInputsContainer = document.getElementById('practice-inputs');
            addPracticeBtn = document.getElementById('add-practice-btn');
            correctionArea = document.getElementById('correction-area');
            correctionInput = document.getElementById('correction-input');
            correctionCheckBtn = document.getElementById('correction-check-btn');
            correctionMsg = document.getElementById('correction-msg');
            retryBtn = document.getElementById('retry-btn');

            // Restore saved history and mastery threshold on page load.  This allows the app to
            // remember which words were learned and the selected streak threshold.
            const savedState = loadState();
            const thresholdSelect = document.getElementById('streak-threshold');
            if (savedState) {
                // If a history object was saved, restore it
                if (savedState.history) {
                    practiceHistory = savedState.history;
                }
                // If a threshold value was saved, restore it
                if (savedState.threshold) {
                    masteryStreak = savedState.threshold;
                }
                // Update the threshold dropdown to reflect the saved value
                if (thresholdSelect && masteryStreak) {
                    thresholdSelect.value = masteryStreak.toString();
                }
            }
            // Update learned words display based on restored state
            if (typeof updateLearnedSection === 'function') updateLearnedSection();

            // Random button handlers
            randomBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const idx = parseInt(btn.getAttribute('data-index'));
                    const input = document.getElementById('w' + idx);
                    if(input){
                        input.value = pickRandomWord();
                        clearBad(idx);
                        renderSuggestions(idx, []);
                    }
                });
            });

            // Start practice handler with suggestions and validation
            startBtn.addEventListener('click', () => {
                const words = [];
                const flagged = [];
                // Iterate over each input field by index
                for(let i = 0; i < 5; i++){
                    const input = document.getElementById('w' + i);
                    if(!input) continue;
                    const raw = (input.value || '').trim();
                    // clear previous hints
                    renderSuggestions(i, []);
                    clearBad(i);
                    if(!raw) continue;
                    const token = raw.split(/\s+/)[0];
                    // enforce single word
                    input.value = token;
                    const suspicious = looksSuspicious(token);
                    const sugs = suspicious ? getSuggestions(token, 5) : [];
                    if(suspicious){
                        markBad(i);
                        renderSuggestions(i, sugs);
                        flagged.push({i, w: token, sugs});
                    } else {
                        // not suspicious; still provide suggestions if word not exactly in dictionary
                        if(!COMMON_WORDS.includes(token.toLowerCase())){
                            const extra = getSuggestions(token, 5);
                            renderSuggestions(i, extra);
                        }
                    }
                    words.push({word: token, meaning: '', syllables: splitIntoSyllables(token)});
                }
                // Filter out empty entries
                const activeWords = words.filter(item => item.word && item.word.length > 0);
                if(activeWords.length === 0){
                    alert('Please enter at least one word.');
                    return;
                }
                // If any suspicious entries, prompt user
                if(flagged.length){
                    const msg = 'The following words may be misspelled or missing vowels:\n\n' +
                        flagged.map(f => '‚Ä¢ ' + f.w + (f.sugs.length ? '  (suggestions: ' + f.sugs.join(', ') + ')' : '')).join('\n') +
                        '\n\nFix them or press OK to practise anyway.';
                    if(!confirm(msg)) return;
                }
                // Save list and move to practice
                // Reset practice history for a new set and read the mastery threshold from the select
                practiceHistory = {};
                const selectElement = document.getElementById('streak-threshold');
                if (selectElement) {
                    masteryStreak = parseInt(selectElement.value) || 3;
                    // Disable the selector during an active practice session to prevent mid-session changes
                    selectElement.disabled = true;
                } else {
                    masteryStreak = 3;
                }
                wordList = activeWords;
                currentIndex = 0;
                // Persist initial state before starting practice (includes history and threshold)
                saveState();
                // Ensure learned section is refreshed when starting a new practice session
                updateLearnedSection();
                // Switch to the practice view with fade transition
                showPage('practice-card');
                updatePrintArea();
                loadCurrentWord();
            });
            // Add more practice row handler
            addPracticeBtn.addEventListener('click', () => {
                if(currentIndex < wordList.length) createPracticeRow(wordList[currentIndex].word);
            });
            // Audio handlers
            listenBtn.addEventListener('click', () => {
                if(currentIndex < wordList.length) speak(wordList[currentIndex].word);
            });
            listenAgainBtn.addEventListener('click', () => {
                if(currentIndex < wordList.length) speak(wordList[currentIndex].word);
            });
            // Navigate to recall stage
            nextStageBtn.addEventListener('click', showRecallStage);
            // Check recall answer
            checkBtn.addEventListener('click', checkAnswer);
            // Check correction
            correctionCheckBtn.addEventListener('click', checkCorrection);
            // Retry memory from correction flow
            retryBtn.addEventListener('click', retryMemory);
            // Move to next word
            nextWordBtn.addEventListener('click', nextWord);
            // Print words for tracing.  Instead of toggling a hidden area, open a new
            // window with a simple layout for tracing and trigger the browser print
            // dialog.  Users can then save as PDF or print directly.
            printBtn.addEventListener('click', () => {
                generateTracingWorksheet();
            });

            // Resume saved words or clear saved set actions
            const resumeSavedBtn = document.getElementById('resume-saved-btn');
            const clearSavedBtn = document.getElementById('clear-saved-btn');
            if (resumeSavedBtn) {
                resumeSavedBtn.addEventListener('click', () => {
                    const savedSet = loadState();
                    if (savedSet && savedSet.wordList && savedSet.wordList.length) {
                        wordList = savedSet.wordList;
                        currentIndex = 0;
                        // Restore history and threshold for the saved session
                        if (savedSet.history) {
                            practiceHistory = savedSet.history;
                        }
                        if (savedSet.threshold) {
                            masteryStreak = savedSet.threshold;
                        }
                        const streakSel = document.getElementById('streak-threshold');
                        if (streakSel) {
                            streakSel.value = masteryStreak.toString();
                            streakSel.disabled = true;
                        }
                        // Switch to practice view
                        showPage('practice-card');
                        updatePrintArea();
                        updateLearnedSection();
                        loadCurrentWord();
                    }
                });
            }
            if (clearSavedBtn) {
                clearSavedBtn.addEventListener('click', () => {
                    clearState();
                    // Reset local practice history and re-enable threshold selector
                    practiceHistory = {};
                    const streakSel = document.getElementById('streak-threshold');
                    if (streakSel) {
                        streakSel.disabled = false;
                    }
                    updateSavedSection();
                    updateLearnedSection();
                });
            }

            // Reset all learned words to active when clicking the reset button
            const resetAllBtn = document.getElementById('reset-all-btn');
            if (resetAllBtn) {
                resetAllBtn.addEventListener('click', () => {
                    // Iterate through practiceHistory and mark all words as not learned with zero streak
                    for (const w in practiceHistory) {
                        const rec = practiceHistory[w];
                        if (rec) {
                            rec.learned = false;
                            rec.streak = 0;
                        }
                    }
                    saveState();
                    updateLearnedSection();
                    updateProgress();
                });
            }

            // Reset all learned words from the learned page
            const resetLearnedPageBtn = document.getElementById('reset-learned-page-btn');
            if (resetLearnedPageBtn) {
                resetLearnedPageBtn.addEventListener('click', () => {
                    for (const w in practiceHistory) {
                        const rec = practiceHistory[w];
                        if (rec) {
                            rec.learned = false;
                            rec.streak = 0;
                        }
                    }
                    saveState();
                    updateLearnedSection();
                    updateProgress();
                });
            }

            // Navigation bar handlers
            const navHome = document.getElementById('nav-home');
            if (navHome) navHome.addEventListener('click', (e) => { e.preventDefault(); showPage('home-card'); });
            const navNew = document.getElementById('nav-new');
            if (navNew) navNew.addEventListener('click', (e) => {
                e.preventDefault();
                const savedLock = loadState();
                if (isLockedToday(savedLock)) {
                    showPage('congrats-card');
                } else {
                    showPage('setup-card');
                }
            });
            const navSaved = document.getElementById('nav-saved');
            if (navSaved) navSaved.addEventListener('click', (e) => { e.preventDefault(); showPage('setup-card', 'saved-section'); });
            const navLearned = document.getElementById('nav-learned');
            if (navLearned) navLearned.addEventListener('click', (e) => { e.preventDefault(); showPage('learned-page'); });

            // Home page button handlers
            const homeNewBtn = document.getElementById('home-new-btn');
            if (homeNewBtn) homeNewBtn.addEventListener('click', () => {
                const savedLock = loadState();
                if (isLockedToday(savedLock)) {
                    showPage('congrats-card');
                } else {
                    showPage('setup-card');
                }
            });
            const homeSavedBtn = document.getElementById('home-saved-btn');
            if (homeSavedBtn) homeSavedBtn.addEventListener('click', () => { showPage('setup-card', 'saved-section'); });
            const homeLearnedBtn = document.getElementById('home-learned-btn');
            if (homeLearnedBtn) homeLearnedBtn.addEventListener('click', () => { showPage('learned-page'); });

            // Congrats page button handlers
            const goSavedBtn = document.getElementById('go-saved');
            const goLearnedBtn = document.getElementById('go-learned');
            const overrideUnlockBtn = document.getElementById('override-unlock');
            if (goSavedBtn) goSavedBtn.addEventListener('click', () => { showPage('setup-card', 'saved-section'); });
            if (goLearnedBtn) goLearnedBtn.addEventListener('click', () => { showPage('learned-page'); });
            if (overrideUnlockBtn) overrideUnlockBtn.addEventListener('click', () => {
                // Clear daily lock and return home
                const st = loadState() || {};
                delete st.lastPracticeDate;
                delete st.lockedUntil;
                saveState(st);
                alert('Practice unlocked for today.');
                showPage('home-card');
            });

            // On initial load, display the appropriate page.  If the user already practised today
            // (lastPracticeDate === today), show the congrats page; otherwise show home.
            const savedForLock = loadState();
            if (isLockedToday(savedForLock)) {
                showPage('congrats-card');
            } else {
                showPage('home-card');
            }

            // Update saved and learned sections on initial load
            if (typeof updateSavedSection === 'function') updateSavedSection();
            if (typeof updateLearnedSection === 'function') updateLearnedSection();

            // Check for previously saved state and offer to resume the session.  Skip this
            // prompt if the user has already practised today (daily lock) to prevent
            // continued practice on the same day.  If not locked and there is a saved
            // session, prompt to resume if partially completed.  Otherwise simply keep
            // the saved words available via the saved words section.
            const saved = loadState();
            if (saved && saved.wordList && saved.wordList.length && !isLockedToday(saved)) {
                const idx = saved.currentIndex || 0;
                const total = saved.wordList.length;
                const inProgress = idx > 0 && idx < total;
                if (inProgress) {
                    if (confirm(`Resume your last session with ${saved.wordList.length} word(s)?`)) {
                        // Restore history and threshold
                        if (saved.history) {
                            practiceHistory = saved.history;
                        }
                        if (saved.threshold) {
                            masteryStreak = saved.threshold;
                        }
                        // Resume from where the user left off
                        wordList = saved.wordList;
                        currentIndex = Math.min(idx, wordList.length);
                        const streakSel = document.getElementById('streak-threshold');
                        if (streakSel) {
                            streakSel.value = masteryStreak.toString();
                            streakSel.disabled = true;
                        }
                        // Switch to practice view
                        showPage('practice-card');
                        updatePrintArea();
                        updateLearnedSection();
                        loadCurrentWord();
                    } else {
                        // User declined to resume; reset progress but keep the saved words
                        wordList = saved.wordList;
                        currentIndex = 0;
                        // Persist the reset state (which includes the history and threshold)
                        saveState();
                        if (typeof updateSavedSection === 'function') updateSavedSection();
                        if (typeof updateLearnedSection === 'function') updateLearnedSection();
                    }
                }
                // If not in progress, the saved words and learned words sections will already be
                // rendered by updateSavedSection() and updateLearnedSection().
            }
        });
    </script>
</body>
</html>